/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@google/dscc/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@google/dscc/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n  @license\n  Copyright 2019 Google LLC\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@google/dscc/lib/types.js\");\n// Make all exported types available to external users.\n__export(__webpack_require__(/*! ./types */ \"./node_modules/@google/dscc/lib/types.js\"));\n/**\n * Returns the width (in pixels) of the vis's iframe.\n *\n * Usage:\n * ```\n * var myWidth = dscc.getWidth();\n * console.log('My width is: ', myWidth);\n * ```\n */\nexports.getWidth = function () { return document.body.clientWidth; };\n/**\n * Returns the height (in pixels) of the vis's iframe.\n *\n * Usage:\n * ```\n * var myHeight = dscc.getHeight();\n * console.log('My height is: ', myHeight);\n * ```\n */\nexports.getHeight = function () { return document.documentElement.clientHeight; };\n/**\n * Returns the componentId of the vis. Component ids uniquely identify a vis to\n * Data Studio.\n *\n * Usage:\n * ```\n * var myComponentId = dscc.getComponentId();\n * console.log('My componentId is: ', myComponentId);\n * ```\n */\nexports.getComponentId = function () {\n    var params = new URLSearchParams(window.location.search);\n    if (params.get('dscId') !== null) {\n        return params.get('dscId');\n    }\n    else {\n        throw new Error('dscId must be in the query parameters. ' +\n            'This is a bug in ds-component, please file a bug: ' +\n            'https://github.com/googledatastudio/ds-component/issues/new');\n    }\n};\n/**\n * Returns the fields indexed by their Data Studio id.\n */\nvar fieldsById = function (message) {\n    return message.fields.reduce(function (acc, field) {\n        acc[field.id] = field;\n        return acc;\n    }, {});\n};\n/**\n * Zips two arrays together into a new array. Uses the length of the shortest\n * array.\n *\n * Usage:\n * ```\n * const a = [1, 2, 3];\n * const b = ['a', 'b', 'c', 'd'];\n * const zipped = zip2(a, b);\n * expect(zipped).toEqual([[1, 'a'], [2, 'b'], [3, 'c']]);\n * ```\n */\nvar zip2 = function (t, u) {\n    if (t.length < u.length) {\n        return t.map(function (tEntry, idx) { return [tEntry, u[idx]]; });\n    }\n    else {\n        return u.map(function (uEntry, idx) { return [t[idx], uEntry]; });\n    }\n};\n// `.sort` isn't stable, but if you compare items, and when they are equal use\n// the original index, it is then stable.\nvar stableSort = function (arr, compare) {\n    return arr\n        .map(function (item, index) { return ({ item: item, index: index }); })\n        .sort(function (a, b) { return compare(a.item, b.item) || a.index - b.index; })\n        .map(function (_a) {\n        var item = _a.item;\n        return item;\n    });\n};\nvar dimensionOrMetric = function (cde) {\n    return cde.type === types_1.ConfigDataElementType.DIMENSION ||\n        cde.type === types_1.ConfigDataElementType.METRIC;\n};\nvar toNum = function (cdet) {\n    return cdet === types_1.ConfigDataElementType.DIMENSION ? -1 : 1;\n};\nvar flattenConfigIds = function (message) {\n    var dimnsAndMets = [];\n    message.config.data.forEach(function (configData) {\n        configData.elements\n            .filter(dimensionOrMetric)\n            .forEach(function (configDataElement) {\n            dimnsAndMets.push(configDataElement);\n        });\n    });\n    var sorted = stableSort(dimnsAndMets, function (a, b) { return toNum(a.type) - toNum(b.type); });\n    var configIds = [];\n    sorted.forEach(function (configDataElement) {\n        configDataElement.value.forEach(function () { return configIds.push(configDataElement.id); });\n    });\n    return configIds;\n};\n/**\n * Joins a single table row with the matching `ConfigId`\n */\nvar joinObjectRow = function (configIds) { return function (row) {\n    var objectRow = {};\n    zip2(row, configIds).forEach(function (_a) {\n        var rowVal = _a[0], configId = _a[1];\n        if (objectRow[configId] === undefined) {\n            objectRow[configId] = [];\n        }\n        objectRow[configId].push(rowVal);\n    }, {});\n    return objectRow;\n}; };\n/**\n * Formats tables into the `ObjectTables` format.\n */\nvar objectFormatTable = function (message) {\n    var _a;\n    var configIds = flattenConfigIds(message);\n    var objectTables = (_a = {}, _a[types_1.TableType.DEFAULT] = [], _a);\n    message.dataResponse.tables.forEach(function (table) {\n        var objectRows = table.rows.map(joinObjectRow(configIds));\n        if (table.id === types_1.TableType.DEFAULT) {\n            objectTables[table.id] = objectRows;\n        }\n        else {\n            var current = objectTables[table.id];\n            if (current === undefined) {\n                objectTables[table.id] = [];\n            }\n            objectTables[table.id] = objectTables[table.id].concat(objectRows);\n        }\n    });\n    return objectTables;\n};\n/**\n * Formats tables into the `Tables` format.\n */\nvar tableFormatTable = function (message) {\n    var _a;\n    var fieldsBy = exports.fieldsByConfigId(message);\n    var configIds = flattenConfigIds(message);\n    var configIdIdx = {};\n    var headers = configIds.map(function (configId) {\n        if (configIdIdx[configId] === undefined) {\n            configIdIdx[configId] = 0;\n        }\n        else {\n            configIdIdx[configId]++;\n        }\n        var idx = configIdIdx[configId];\n        var field = fieldsBy[configId][idx];\n        var heading = __assign(__assign({}, field), { configId: configId });\n        return heading;\n    });\n    var tableTables = (_a = {},\n        _a[types_1.TableType.DEFAULT] = { headers: [], rows: [] },\n        _a);\n    message.dataResponse.tables.forEach(function (table) {\n        tableTables[table.id] = {\n            headers: headers,\n            rows: table.rows,\n        };\n    });\n    return tableTables;\n};\n/**\n * Returns the fields indexed by their config id. Since many fields can be in\n * the same `METRIC`/`DIMENSION` selection, `configId` is mapped to `Field[]`.\n */\nexports.fieldsByConfigId = function (message) {\n    var fieldsByDSId = fieldsById(message);\n    var fieldsBy = {};\n    message.config.data.forEach(function (configData) {\n        configData.elements\n            .filter(dimensionOrMetric)\n            .forEach(function (configDataElement) {\n            fieldsBy[configDataElement.id] = configDataElement.value.map(function (dsId) { return fieldsByDSId[dsId]; });\n        });\n    });\n    return fieldsBy;\n};\n/**\n * Flattens the style entries into a single object. `styleId`s should be unique.\n */\nvar flattenStyle = function (message) {\n    var styleById = {};\n    (message.config.style || []).forEach(function (styleEntry) {\n        styleEntry.elements.forEach(function (configStyleElement) {\n            if (styleById[configStyleElement.id] !== undefined) {\n                throw new Error(\"styleIds must be unique. Your styleId: '\" + configStyleElement.id + \"' is used more than once.\");\n            }\n            styleById[configStyleElement.id] = {\n                value: configStyleElement.value,\n                defaultValue: configStyleElement.defaultValue,\n            };\n        });\n    }, {});\n    return styleById;\n};\nvar themeStyle = function (message) {\n    return message.config.themeStyle;\n};\nvar mapInteractionTypes = function (dsInteraction) {\n    switch (dsInteraction) {\n        case types_1.DSInteractionType.FILTER:\n            return types_1.InteractionType.FILTER;\n    }\n};\nvar transformDSInteraction = function (message) {\n    var dsInteractions = message.config.interactions;\n    // TODO - remove once interactions are live.\n    if (dsInteractions === undefined) {\n        return {};\n    }\n    return dsInteractions.reduce(function (acc, dsInteraction) {\n        var interactions = dsInteraction.supportedActions.map(mapInteractionTypes);\n        var value = {\n            type: mapInteractionTypes(dsInteraction.value.type),\n            data: dsInteraction.value.data,\n        };\n        acc[dsInteraction.id] = {\n            value: value,\n            supportedActions: interactions,\n        };\n        return acc;\n    }, {});\n};\n/**\n * Transform for date ranges\n */\nvar toDateRanges = function (message) {\n    var dateRanges = message.dataResponse.dateRanges || [];\n    var output = {};\n    return dateRanges.reduce(function (inProgress, currentDSDateRange) {\n        inProgress[currentDSDateRange.id] = {\n            start: currentDSDateRange.start,\n            end: currentDSDateRange.end,\n        };\n        return inProgress;\n    }, output);\n};\n/* Transform for color maps */\nvar toColorsByDimension = function (message) {\n    var colors = message.dataResponse.colorMap || {};\n    return __assign({}, colors);\n};\n/**\n * The transform to use for data in a Table format. i.e. `[[1, 2, 3], [4, 5, 6]]`\n */\nexports.tableTransform = function (message) { return ({\n    tables: tableFormatTable(message),\n    dateRanges: toDateRanges(message),\n    fields: exports.fieldsByConfigId(message),\n    style: flattenStyle(message),\n    theme: themeStyle(message),\n    interactions: transformDSInteraction(message),\n    colorMap: toColorsByDimension(message),\n}); };\n/**\n * The transform to use for data in an object format. i.e. `[{name: 'john', views: 3}, {name: 'suzie', views: 5}]`\n */\nexports.objectTransform = function (message) { return ({\n    tables: objectFormatTable(message),\n    dateRanges: toDateRanges(message),\n    fields: exports.fieldsByConfigId(message),\n    style: flattenStyle(message),\n    theme: themeStyle(message),\n    interactions: transformDSInteraction(message),\n    colorMap: toColorsByDimension(message),\n}); };\n/**\n * Check if the transform is likely the identity function\n * This is not a supported implementation path\n * Avoid this if at all possible - please use either objectTransform or tableTransform\n */\nvar isProbablyIdentityFunction = function (transform) {\n    var isIdentity = false;\n    if (transform('identity') === 'identity') {\n        isIdentity = true;\n        console.warn(\"This is an unsupported data format. Please use one of the supported transforms:\\n       dscc.objectFormat or dscc.tableFormat.\");\n    }\n    return isIdentity;\n};\nvar isValidTransform = function (transform) {\n    var isValid = false;\n    if (transform === exports.tableTransform ||\n        transform === exports.objectTransform) {\n        isValid = true;\n    }\n    else if (isProbablyIdentityFunction(transform)) {\n        isValid = true;\n    }\n    return isValid;\n};\n/*\n * Subscribes to messages from Data Studio. Calls `cb` for every new\n * [[MessageType.RENDER]] message. Returns a function that will unsubscribe\n * `callback` from further invocations.\n *\n * Usage - tableTransform:\n * ```\n * var unsubscribe = dscc.subscribeToData(function(message) {\n *   console.log(message.tables)\n *   console.log(message.fields)\n *   console.log(message.style)\n * }, {transform: dscc.tableTransform});\n *\n * setTimeout(function() {\n *   unsubscribe();\n * }, 3000)\n * ```\n\n * Usage - objectTransform:\n * ```\n * var unsubscribe = dscc.subscribeToData(function(message) {\n *   console.log(message.tables)\n *   console.log(message.fields)\n *   console.log(message.style)\n * }, {transform: dscc.objectTransform});\n *\n * setTimeout(function() {\n *   unsubscribe();\n * }, 3000)\n * ```\n */\nexports.subscribeToData = function (cb, options) {\n    if (isValidTransform(options.transform)) {\n        var onMessage_1 = function (message) {\n            if (message.data.type === types_1.MessageType.RENDER) {\n                cb(options.transform(message.data));\n            }\n            else {\n                console.error(\"MessageType: \" + message.data.type + \" is not supported by this version of the library.\");\n            }\n        };\n        window.addEventListener('message', onMessage_1);\n        var componentId = exports.getComponentId();\n        // Tell DataStudio that the viz is ready to get events.\n        var vizReadyMessage = {\n            componentId: componentId,\n            type: types_1.ToDSMessageType.VIZ_READY,\n        };\n        window.parent.postMessage(vizReadyMessage, '*');\n        return function () { return window.removeEventListener('message', onMessage_1); };\n    }\n    else {\n        throw new Error(\"Only the built in transform functions are supported.\");\n    }\n};\n/*\n * Does the thing that interactions should do.\n */\nexports.sendInteraction = function (actionId, interaction, data) {\n    var componentId = exports.getComponentId();\n    var interactionMessage = {\n        type: types_1.ToDSMessageType.INTERACTION,\n        id: actionId,\n        data: data,\n        componentId: componentId,\n    };\n    window.parent.postMessage(interactionMessage, '*');\n};\n/*\n * Clears an interaction\n */\nexports.clearInteraction = function (actionId, interaction) {\n    exports.sendInteraction(actionId, interaction, undefined);\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@google/dscc/lib/index.js?");

/***/ }),

/***/ "./node_modules/@google/dscc/lib/types.js":
/*!************************************************!*\
  !*** ./node_modules/@google/dscc/lib/types.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConceptType;\n(function (ConceptType) {\n    ConceptType[\"METRIC\"] = \"METRIC\";\n    ConceptType[\"DIMENSION\"] = \"DIMENSION\";\n})(ConceptType = exports.ConceptType || (exports.ConceptType = {}));\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"RENDER\"] = \"RENDER\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nvar FieldType;\n(function (FieldType) {\n    FieldType[\"YEAR\"] = \"YEAR\";\n    FieldType[\"YEAR_QUARTER\"] = \"YEAR_QUARTER\";\n    FieldType[\"YEAR_MONTH\"] = \"YEAR_MONTH\";\n    FieldType[\"YEAR_WEEK\"] = \"YEAR_WEEK\";\n    FieldType[\"YEAR_MONTH_DAY\"] = \"YEAR_MONTH_DAY\";\n    FieldType[\"YEAR_MONTH_DAY_HOUR\"] = \"YEAR_MONTH_DAY_HOUR\";\n    FieldType[\"QUARTER\"] = \"QUARTER\";\n    FieldType[\"MONTH\"] = \"MONTH\";\n    FieldType[\"WEEK\"] = \"WEEK\";\n    FieldType[\"MONTH_DAY\"] = \"MONTH_DAY\";\n    FieldType[\"DAY_OF_WEEK\"] = \"DAY_OF_WEEK\";\n    FieldType[\"DAY\"] = \"DAY\";\n    FieldType[\"HOUR\"] = \"HOUR\";\n    FieldType[\"MINUTE\"] = \"MINUTE\";\n    FieldType[\"DURATION\"] = \"DURATION\";\n    FieldType[\"COUNTRY\"] = \"COUNTRY\";\n    FieldType[\"COUNTRY_CODE\"] = \"COUNTRY_CODE\";\n    FieldType[\"CONTINENT\"] = \"CONTINENT\";\n    FieldType[\"CONTINENT_CODE\"] = \"CONTINENT_CODE\";\n    FieldType[\"SUB_CONTINENT\"] = \"SUB_CONTINENT\";\n    FieldType[\"SUB_CONTINENT_CODE\"] = \"SUB_CONTINENT_CODE\";\n    FieldType[\"REGION\"] = \"REGION\";\n    FieldType[\"REGION_CODE\"] = \"REGION_CODE\";\n    FieldType[\"CITY\"] = \"CITY\";\n    FieldType[\"CITY_CODE\"] = \"CITY_CODE\";\n    FieldType[\"METRO_CODE\"] = \"METRO_CODE\";\n    FieldType[\"LATITUDE_LONGITUDE\"] = \"LATITUDE_LONGITUDE\";\n    FieldType[\"NUMBER\"] = \"NUMBER\";\n    FieldType[\"PERCENT\"] = \"PERCENT\";\n    FieldType[\"TEXT\"] = \"TEXT\";\n    FieldType[\"BOOLEAN\"] = \"BOOLEAN\";\n    FieldType[\"URL\"] = \"URL\";\n    FieldType[\"IMAGE\"] = \"IMAGE\";\n    FieldType[\"CURRENCY_AED\"] = \"CURRENCY_AED\";\n    FieldType[\"CURRENCY_ALL\"] = \"CURRENCY_ALL\";\n    FieldType[\"CURRENCY_ARS\"] = \"CURRENCY_ARS\";\n    FieldType[\"CURRENCY_AUD\"] = \"CURRENCY_AUD\";\n    FieldType[\"CURRENCY_BDT\"] = \"CURRENCY_BDT\";\n    FieldType[\"CURRENCY_BGN\"] = \"CURRENCY_BGN\";\n    FieldType[\"CURRENCY_BOB\"] = \"CURRENCY_BOB\";\n    FieldType[\"CURRENCY_BRL\"] = \"CURRENCY_BRL\";\n    FieldType[\"CURRENCY_CAD\"] = \"CURRENCY_CAD\";\n    FieldType[\"CURRENCY_CDF\"] = \"CURRENCY_CDF\";\n    FieldType[\"CURRENCY_CHF\"] = \"CURRENCY_CHF\";\n    FieldType[\"CURRENCY_CLP\"] = \"CURRENCY_CLP\";\n    FieldType[\"CURRENCY_CNY\"] = \"CURRENCY_CNY\";\n    FieldType[\"CURRENCY_COP\"] = \"CURRENCY_COP\";\n    FieldType[\"CURRENCY_CRC\"] = \"CURRENCY_CRC\";\n    FieldType[\"CURRENCY_CZK\"] = \"CURRENCY_CZK\";\n    FieldType[\"CURRENCY_DKK\"] = \"CURRENCY_DKK\";\n    FieldType[\"CURRENCY_DOP\"] = \"CURRENCY_DOP\";\n    FieldType[\"CURRENCY_EGP\"] = \"CURRENCY_EGP\";\n    FieldType[\"CURRENCY_ETB\"] = \"CURRENCY_ETB\";\n    FieldType[\"CURRENCY_EUR\"] = \"CURRENCY_EUR\";\n    FieldType[\"CURRENCY_GBP\"] = \"CURRENCY_GBP\";\n    FieldType[\"CURRENCY_HKD\"] = \"CURRENCY_HKD\";\n    FieldType[\"CURRENCY_HRK\"] = \"CURRENCY_HRK\";\n    FieldType[\"CURRENCY_HUF\"] = \"CURRENCY_HUF\";\n    FieldType[\"CURRENCY_IDR\"] = \"CURRENCY_IDR\";\n    FieldType[\"CURRENCY_ILS\"] = \"CURRENCY_ILS\";\n    FieldType[\"CURRENCY_INR\"] = \"CURRENCY_INR\";\n    FieldType[\"CURRENCY_IRR\"] = \"CURRENCY_IRR\";\n    FieldType[\"CURRENCY_ISK\"] = \"CURRENCY_ISK\";\n    FieldType[\"CURRENCY_JMD\"] = \"CURRENCY_JMD\";\n    FieldType[\"CURRENCY_JPY\"] = \"CURRENCY_JPY\";\n    FieldType[\"CURRENCY_KRW\"] = \"CURRENCY_KRW\";\n    FieldType[\"CURRENCY_LKR\"] = \"CURRENCY_LKR\";\n    FieldType[\"CURRENCY_LTL\"] = \"CURRENCY_LTL\";\n    FieldType[\"CURRENCY_MNT\"] = \"CURRENCY_MNT\";\n    FieldType[\"CURRENCY_MVR\"] = \"CURRENCY_MVR\";\n    FieldType[\"CURRENCY_MXN\"] = \"CURRENCY_MXN\";\n    FieldType[\"CURRENCY_MYR\"] = \"CURRENCY_MYR\";\n    FieldType[\"CURRENCY_NOK\"] = \"CURRENCY_NOK\";\n    FieldType[\"CURRENCY_NZD\"] = \"CURRENCY_NZD\";\n    FieldType[\"CURRENCY_PAB\"] = \"CURRENCY_PAB\";\n    FieldType[\"CURRENCY_PEN\"] = \"CURRENCY_PEN\";\n    FieldType[\"CURRENCY_PHP\"] = \"CURRENCY_PHP\";\n    FieldType[\"CURRENCY_PKR\"] = \"CURRENCY_PKR\";\n    FieldType[\"CURRENCY_PLN\"] = \"CURRENCY_PLN\";\n    FieldType[\"CURRENCY_RON\"] = \"CURRENCY_RON\";\n    FieldType[\"CURRENCY_RSD\"] = \"CURRENCY_RSD\";\n    FieldType[\"CURRENCY_RUB\"] = \"CURRENCY_RUB\";\n    FieldType[\"CURRENCY_SAR\"] = \"CURRENCY_SAR\";\n    FieldType[\"CURRENCY_SEK\"] = \"CURRENCY_SEK\";\n    FieldType[\"CURRENCY_SGD\"] = \"CURRENCY_SGD\";\n    FieldType[\"CURRENCY_THB\"] = \"CURRENCY_THB\";\n    FieldType[\"CURRENCY_TRY\"] = \"CURRENCY_TRY\";\n    FieldType[\"CURRENCY_TWD\"] = \"CURRENCY_TWD\";\n    FieldType[\"CURRENCY_TZS\"] = \"CURRENCY_TZS\";\n    FieldType[\"CURRENCY_UAH\"] = \"CURRENCY_UAH\";\n    FieldType[\"CURRENCY_USD\"] = \"CURRENCY_USD\";\n    FieldType[\"CURRENCY_UYU\"] = \"CURRENCY_UYU\";\n    FieldType[\"CURRENCY_VEF\"] = \"CURRENCY_VEF\";\n    FieldType[\"CURRENCY_VND\"] = \"CURRENCY_VND\";\n    FieldType[\"CURRENCY_YER\"] = \"CURRENCY_YER\";\n    FieldType[\"CURRENCY_ZAR\"] = \"CURRENCY_ZAR\";\n})(FieldType = exports.FieldType || (exports.FieldType = {}));\nvar TableType;\n(function (TableType) {\n    TableType[\"DEFAULT\"] = \"DEFAULT\";\n    TableType[\"COMPARISON\"] = \"COMPARISON\";\n    TableType[\"SUMMARY\"] = \"SUMMARY\";\n})(TableType = exports.TableType || (exports.TableType = {}));\nvar DateRangeType;\n(function (DateRangeType) {\n    DateRangeType[\"DEFAULT\"] = \"DEFAULT\";\n    DateRangeType[\"COMPARISON\"] = \"COMPARISON\";\n})(DateRangeType = exports.DateRangeType || (exports.DateRangeType = {}));\nvar ConfigDataElementType;\n(function (ConfigDataElementType) {\n    /**\n     * Renders a metric field element.\n     */\n    ConfigDataElementType[\"METRIC\"] = \"METRIC\";\n    /**\n     * Renders a dimension field element.\n     */\n    ConfigDataElementType[\"DIMENSION\"] = \"DIMENSION\";\n    /**\n     * Renders a dropdown that affects the maximum number of results returned.\n     */\n    ConfigDataElementType[\"MAX_RESULTS\"] = \"MAX_RESULTS\";\n})(ConfigDataElementType = exports.ConfigDataElementType || (exports.ConfigDataElementType = {}));\nvar ConfigStyleElementType;\n(function (ConfigStyleElementType) {\n    /**\n     * Renders a text input box.\n     */\n    ConfigStyleElementType[\"TEXTINPUT\"] = \"TEXTINPUT\";\n    /**\n     * A single select dropdown.\n     */\n    ConfigStyleElementType[\"SELECT_SINGLE\"] = \"SELECT_SINGLE\";\n    /**\n     * Renders a checkbox.\n     *\n     * Default value: `false`\n     */\n    ConfigStyleElementType[\"CHECKBOX\"] = \"CHECKBOX\";\n    /**\n     * Renders the font color selector.\n     *\n     * Acceptable default values: HEX color value. E.g. `\"#888888\"`.\n     *\n     * Default value: `\"#000\"`.\n     */\n    ConfigStyleElementType[\"FONT_COLOR\"] = \"FONT_COLOR\";\n    /**\n     * Renders the font size selector.\n     *\n     * Default value: `\"14px\"`.\n     */\n    ConfigStyleElementType[\"FONT_SIZE\"] = \"FONT_SIZE\";\n    /**\n     * Renders the font family selector.\n     *\n     * Default value: `\"\"`\n     */\n    ConfigStyleElementType[\"FONT_FAMILY\"] = \"FONT_FAMILY\";\n    /**\n     * Renders a fill color selector.\n     *\n     * Acceptable default values: HEX color value.\n     */\n    ConfigStyleElementType[\"FILL_COLOR\"] = \"FILL_COLOR\";\n    /**\n     * Renders a border color selector.\n     *\n     * Acceptable default values: HEX color value.\n     */\n    ConfigStyleElementType[\"BORDER_COLOR\"] = \"BORDER_COLOR\";\n    /**\n     * Renders an axis color selector.\n     *\n     * Acceptable default values: HEX color value.\n     */\n    ConfigStyleElementType[\"AXIS_COLOR\"] = \"AXIS_COLOR\";\n    /**\n     * Renders a grid color selector.\n     *\n     * Acceptable default values: HEX color value.\n     */\n    ConfigStyleElementType[\"GRID_COLOR\"] = \"GRID_COLOR\";\n    /**\n     * Renders an opacity selector.\n     */\n    ConfigStyleElementType[\"OPACITY\"] = \"OPACITY\";\n    /**\n     * Renders a line weight picker.\n     */\n    ConfigStyleElementType[\"LINE_WEIGHT\"] = \"LINE_WEIGHT\";\n    /**\n     * Renders a line style picker.\n     *\n     * Acceptable default values: `\"solid\"`, `\"dashed\"`, `\"dotted\"`, or `\"double\"`.\n     */\n    ConfigStyleElementType[\"LINE_STYLE\"] = \"LINE_STYLE\";\n    /**\n     * Renders a border radius selector.\n     */\n    ConfigStyleElementType[\"BORDER_RADIUS\"] = \"BORDER_RADIUS\";\n    /**\n     * Renders an interval selector.\n     */\n    ConfigStyleElementType[\"INTERVAL\"] = \"INTERVAL\";\n    /**\n     * Renders a radio select with pre-defined values.\n     */\n    ConfigStyleElementType[\"SELECT_RADIO\"] = \"SELECT_RADIO\";\n})(ConfigStyleElementType = exports.ConfigStyleElementType || (exports.ConfigStyleElementType = {}));\nvar DSInteractionType;\n(function (DSInteractionType) {\n    DSInteractionType[\"FILTER\"] = \"FILTER\";\n})(DSInteractionType = exports.DSInteractionType || (exports.DSInteractionType = {}));\nvar ToDSMessageType;\n(function (ToDSMessageType) {\n    ToDSMessageType[\"VIZ_READY\"] = \"vizReady\";\n    ToDSMessageType[\"INTERACTION\"] = \"vizAction\";\n})(ToDSMessageType = exports.ToDSMessageType || (exports.ToDSMessageType = {}));\nvar InteractionType;\n(function (InteractionType) {\n    InteractionType[\"FILTER\"] = \"FILTER\";\n})(InteractionType = exports.InteractionType || (exports.InteractionType = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///./node_modules/@google/dscc/lib/types.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const dscc = __webpack_require__(/*! @google/dscc */ \"./node_modules/@google/dscc/lib/index.js\");\nconsole.log(\"v37 Filter visualization initialized - Delimited field filter with configurable delimiter, compact numbers, and header info\");\n\n/**\n * Main visualization drawing function\n * This is called whenever the data or configuration changes\n * @param {Object} data - The data object from Looker Studio\n */\nfunction drawViz(data) {\n  try {\n    \n    // Get the container dimensions from Looker Studio\n    const width = dscc.getWidth();\n    const height = dscc.getHeight();\n    \n    // Get the dimension field information\n    const dimensionField = data.fields.dimID[0];\n    \n    // Get the delimiter from configuration or use comma as default\n    let delimiter = ',';\n    if (data.style && data.style.delimiterType && data.style.delimiterType.value) {\n      delimiter = data.style.delimiterType.value;\n    }\n    \n    // Check if there's a custom delimiter specified\n    if (data.style && data.style.customDelimiter && data.style.customDelimiter.value && \n        data.style.customDelimiter.value.trim() !== '') {\n      delimiter = data.style.customDelimiter.value;\n    }\n    \n    // Check if compact number formatting is enabled\n    let useCompactNumbers = false;\n    if (data.style && data.style.useCompactNumbers && data.style.useCompactNumbers.value !== undefined) {\n      useCompactNumbers = data.style.useCompactNumbers.value;\n    }\n    \n    // Check if we should show null values\n    let showNullValues = true;\n    if (data.style && data.style.showNullValues && data.style.showNullValues.value !== undefined) {\n      showNullValues = data.style.showNullValues.value;\n    }\n    \n    // Get the text to display for null values\n    let nullDisplayText = \"(null)\";\n    if (data.style && data.style.nullDisplayText && data.style.nullDisplayText.value) {\n      nullDisplayText = data.style.nullDisplayText.value;\n    }\n    \n    // Check if we should show selected count and reset link\n    let showSelectedCount = true;\n    let showResetLink = true;\n    let resetLinkText = 'Reset';\n    \n    if (data.style && data.style.showSelectedCount && data.style.showSelectedCount.value !== undefined) {\n      showSelectedCount = data.style.showSelectedCount.value;\n    }\n    \n    if (data.style && data.style.showResetLink && data.style.showResetLink.value !== undefined) {\n      showResetLink = data.style.showResetLink.value;\n    }\n    \n    if (data.style && data.style.resetLinkText && data.style.resetLinkText.value) {\n      resetLinkText = data.style.resetLinkText.value;\n    }\n        \n    // Extract all unique values from the dimension and store their metrics\n    const dimensionMetrics = new Map();\n    const individualValueCounts = new Map(); // Track counts for individual values\n    const delimitedValues = new Map(); // Track which values appear in delimited fields\n    \n    // Process all rows to extract unique values and handle delimited fields\n    data.tables.DEFAULT.forEach(row => {\n      if (row.dimID && row.dimID.length > 0) {\n        const dimValue = row.dimID[0];\n        // Get the metric value - ensure it's a number\n        const metricValue = row.metricID && row.metricID.length > 0 ? Number(row.metricID[0]) : 0;\n        \n        // Handle null, undefined, or empty values\n        const isNullish = dimValue === null || dimValue === undefined || dimValue === '';\n        \n        // Skip null values if showNullValues is false\n        if (!showNullValues && isNullish) {\n          return;\n        }\n        \n        // Handle null or undefined values with the configured display text\n        const dimValueStr = isNullish ? nullDisplayText : String(dimValue);\n        \n        // Check if this is a delimited field (contains the delimiter)\n        if (!isNullish && String(dimValue).includes(delimiter)) {\n          // Split the delimited field and process each value\n          const individualValues = dimValueStr.split(delimiter).map(v => v.trim());\n          \n          // Add each individual value to our tracking\n          individualValues.forEach(individualValue => {\n            // Skip empty values\n            if (!individualValue) return;\n            \n            // Track that this individual value appears in delimited fields\n            if (!delimitedValues.has(individualValue)) {\n              delimitedValues.set(individualValue, new Set());\n            }\n            delimitedValues.get(individualValue).add(dimValueStr);\n            \n            // Increment the count for this individual value\n            if (!individualValueCounts.has(individualValue)) {\n              individualValueCounts.set(individualValue, metricValue);\n            } else {\n              individualValueCounts.set(individualValue, individualValueCounts.get(individualValue) + metricValue);\n            }\n          });\n          \n          // Add the full delimited value to our metrics\n          if (dimensionMetrics.has(dimValueStr)) {\n            dimensionMetrics.set(dimValueStr, dimensionMetrics.get(dimValueStr) + metricValue);\n          } else {\n            dimensionMetrics.set(dimValueStr, metricValue);\n          }\n        } else {\n          // Single value, add to our metrics\n          if (dimensionMetrics.has(dimValueStr)) {\n            dimensionMetrics.set(dimValueStr, dimensionMetrics.get(dimValueStr) + metricValue);\n          } else {\n            dimensionMetrics.set(dimValueStr, metricValue);\n          }\n          \n          // Also track the count for this individual value\n          if (!individualValueCounts.has(dimValueStr)) {\n            individualValueCounts.set(dimValueStr, metricValue);\n          } else {\n            individualValueCounts.set(dimValueStr, individualValueCounts.get(dimValueStr) + metricValue);\n          }\n        }\n      }\n    });\n    \n    // Get unique individual values (non-delimited)\n    const uniqueIndividualValues = new Set();\n    dimensionMetrics.forEach((_, key) => {\n      // Include null values (represented by nullDisplayText) if showNullValues is true\n      \n      // Convert to string to ensure we can use string methods\n      const keyStr = String(key);\n      if ((keyStr === nullDisplayText && showNullValues) || (!keyStr.includes(delimiter) && keyStr !== '')) {\n        uniqueIndividualValues.add(keyStr);\n      }\n    });\n    \n    // Convert to sorted array for display - only show individual values, not delimited ones\n    const sortedDimensionValues = Array.from(uniqueIndividualValues).sort();\n  \n    // Add items to the list\n    let selectedItems = new Set(sortedDimensionValues); // Start with all selected\n    let initiallyAllSelected = true; // Track if we start with all selected\n    \n    // Check if there's an active filter from Looker Studio\n    if (data.interactions && data.interactions.onClick && \n        data.interactions.onClick.value && \n        data.interactions.onClick.value.data) {\n      const filterData = data.interactions.onClick.value.data;\n      if (filterData.values && filterData.values.length > 0) {\n        // There's an active filter, so we should only select those items\n        selectedItems.clear();\n        initiallyAllSelected = false;\n        \n        // First, collect all the values from the filter\n        const filterValues = new Set();\n        filterData.values.forEach(valueArray => {\n          if (valueArray && valueArray.length > 0) {\n            const value = valueArray[0];\n            \n            // Handle null, undefined, or empty values\n            const isNullish = value === null || value === undefined || value === '';\n            \n            // Skip null values if showNullValues is false\n            if (!showNullValues && isNullish) {\n              return;\n            }\n            \n            // Handle null or undefined values with the configured display text\n            const valueStr = isNullish ? nullDisplayText : String(value);\n            filterValues.add(valueStr);\n          }\n        });\n        \n        // Then, select only the individual values that are explicitly in the filter\n        // Do NOT automatically select other values from delimited fields\n        sortedDimensionValues.forEach(value => {\n          if (filterValues.has(value)) {\n            selectedItems.add(value);\n          }\n        });\n        \n        // Check if we ended up with all items selected again\n        if (selectedItems.size === sortedDimensionValues.length) {\n          initiallyAllSelected = true;\n        }\n      }\n    }\n    \n    // Function to sort values with selected items at the top\n    function getSortedValues() {\n      // If all items are selected or none are selected, just use alphabetical order\n      if (selectedItems.size === 0 || selectedItems.size === sortedDimensionValues.length) {\n        return [...sortedDimensionValues];\n      }\n      \n      // Otherwise, put selected items at the top\n      const selected = [];\n      const unselected = [];\n      \n      sortedDimensionValues.forEach(value => {\n        if (selectedItems.has(value)) {\n          selected.push(value);\n        } else {\n          unselected.push(value);\n        }\n      });\n      \n      // Sort each group alphabetically\n      selected.sort();\n      unselected.sort();\n      \n      // Return combined array with selected items first\n      return [...selected, ...unselected];\n    }\n    \n    // Get the sorted values with selected items at the top\n    const displayValues = getSortedValues();\n    \n    // Extract style configuration with defaults\n    const styles = {\n      // General appearance\n      fontFamily: 'Roboto, Arial, sans-serif',\n      fontSize: '14px',\n      backgroundColor: '#ffffff',\n      \n      // Header section\n      headerBackgroundColor: '#f8f9fa',\n      headerTextColor: '#202124',\n      headerFontWeight: '500',\n      headerBorderColor: '#dadce0',\n      \n      // Search section\n      searchBackgroundColor: '#ffffff',\n      searchTextColor: '#202124',\n      searchPlaceholderText: 'Type to search',\n      searchBorderColor: '#dadce0',\n      \n      // List items\n      itemBackgroundColor: '#ffffff',\n      itemHoverColor: '#f1f3f4',\n      itemTextColor: '#202124',\n      itemBorderColor: '#dadce0',\n      \n      // Accent elements\n      accentColor: '#1a73e8',\n      onlyButtonText: 'only',\n      onlyButtonFontSize: '12px',\n      checkboxColor: '#1a73e8'\n    };\n    \n    // Helper function to extract color from style object\n    function getColor(styleObj) {\n      if (styleObj && styleObj.value && styleObj.value.color) {\n        return styleObj.value.color;\n      }\n      return null;\n    }\n    \n    // Apply custom styles if available in the config\n    if (data.style) {\n      console.log(\"Style configuration:\", data.style);\n      \n      const styleUpdates = {\n        // General appearance\n        fontFamily: ['fontFamily', 'value'],\n        fontSize: ['fontSize', 'value', val => val + 'px'],\n        backgroundColor: ['backgroundColor', 'color', getColor],\n        \n        // Header section\n        headerBackgroundColor: ['headerBackgroundColor', 'color', getColor],\n        headerTextColor: ['headerTextColor', 'color', getColor],\n        headerFontWeight: ['headerFontWeight', 'value'],\n        headerBorderColor: ['headerBorderColor', 'color', getColor],\n        \n        // Search section\n        searchBackgroundColor: ['searchBackgroundColor', 'color', getColor],\n        searchTextColor: ['searchTextColor', 'color', getColor],\n        searchPlaceholderText: ['searchPlaceholderText', 'value'],\n        searchBorderColor: ['searchBorderColor', 'color', getColor],\n        \n        // List items\n        itemBackgroundColor: ['itemBackgroundColor', 'color', getColor],\n        itemHoverColor: ['itemHoverColor', 'color', getColor],\n        itemTextColor: ['itemTextColor', 'color', getColor],\n        itemBorderColor: ['itemBorderColor', 'color', getColor],\n        \n        // Accent elements\n        accentColor: ['accentColor', 'color', getColor],\n        onlyButtonText: ['onlyButtonText', 'value'],\n        onlyButtonFontSize: ['onlyButtonFontSize', 'value', val => val + 'px'],\n        checkboxColor: ['checkboxColor', 'color', getColor]\n      };\n\n      // Apply each style update\n      Object.entries(styleUpdates).forEach(([styleKey, [configKey, valueKey, transform = val => val]]) => {\n        const configValue = data.style[configKey];\n        if (configValue && configValue[valueKey] !== undefined) {\n          styles[styleKey] = transform(configValue[valueKey]);\n        }\n      });\n    }\n    \n    console.log(\"Applied styles:\", styles);\n    \n    // Create the main container for our filter UI\n    const filterContainer = document.createElement('div');\n    filterContainer.id = 'lookerStudioFilterContainer';\n    filterContainer.style.position = 'absolute';\n    filterContainer.style.top = '0';\n    filterContainer.style.left = '0';\n    filterContainer.style.width = width + 'px';\n    filterContainer.style.height = height + 'px';\n    filterContainer.style.backgroundColor = styles.backgroundColor;\n    filterContainer.style.fontFamily = styles.fontFamily;\n    filterContainer.style.fontSize = styles.fontSize;\n    filterContainer.style.boxSizing = 'border-box';\n    filterContainer.style.display = 'flex';\n    filterContainer.style.flexDirection = 'column';\n    filterContainer.style.padding = '0';\n    filterContainer.style.margin = '0';\n    filterContainer.style.border = `1px solid ${styles.headerBorderColor}`;\n    filterContainer.style.borderRadius = '4px';\n    filterContainer.style.overflow = 'hidden';\n    \n    // Create the header section\n    const headerSection = document.createElement('div');\n    headerSection.className = 'header';\n    headerSection.style.display = 'flex';\n    headerSection.style.alignItems = 'center';\n    headerSection.style.padding = '8px 16px';\n    headerSection.style.borderBottom = `1px solid ${styles.headerBorderColor}`;\n    headerSection.style.backgroundColor = styles.headerBackgroundColor;\n    headerSection.style.boxSizing = 'border-box';\n    \n    // Create the \"Select all\" checkbox\n    const selectAllCheckbox = document.createElement('input');\n    selectAllCheckbox.type = 'checkbox';\n    selectAllCheckbox.id = 'selectAllCheckbox';\n    selectAllCheckbox.style.marginRight = '8px';\n    selectAllCheckbox.checked = initiallyAllSelected;\n    selectAllCheckbox.indeterminate = selectedItems.size > 0 && selectedItems.size < sortedDimensionValues.length;\n    selectAllCheckbox.style.flexShrink = '0';\n    selectAllCheckbox.style.accentColor = styles.checkboxColor;\n    \n    // Create a custom checkbox container for styling\n    const checkboxContainer = document.createElement('div');\n    checkboxContainer.style.display = 'flex';\n    checkboxContainer.style.alignItems = 'center';\n    checkboxContainer.style.marginRight = '8px';\n    checkboxContainer.style.flexShrink = '0';\n    \n    // Add the checkbox to its container\n    checkboxContainer.appendChild(selectAllCheckbox);\n    \n    // Create the dimension name label for the header\n    const headerDimensionLabel = document.createElement('div');\n    headerDimensionLabel.className = 'dimension-name';\n    headerDimensionLabel.style.fontWeight = styles.headerFontWeight;\n    headerDimensionLabel.style.fontSize = styles.fontSize;\n    headerDimensionLabel.style.color = styles.headerTextColor;\n    headerDimensionLabel.style.flex = '1';\n    headerDimensionLabel.style.whiteSpace = 'nowrap';\n    headerDimensionLabel.style.overflow = 'hidden';\n    headerDimensionLabel.style.textOverflow = 'ellipsis';\n    \n    // Set the dimension name text with selected count if enabled\n    if (showSelectedCount) {\n      // Count only the checked items (not the expanded filter values)\n      const selectedCount = selectedItems.size;\n      \n      // Always show the count of checked items\n      headerDimensionLabel.textContent = `${dimensionField.name} (${formatMetricValue(selectedCount)})`;\n    } else {\n      headerDimensionLabel.textContent = dimensionField.name;\n    }\n    \n    // Add elements to the header\n    headerSection.appendChild(checkboxContainer);\n    headerSection.appendChild(headerDimensionLabel);\n    \n    // Create and add the reset link if enabled\n    if (showResetLink) {\n      const resetLink = document.createElement('a');\n      resetLink.textContent = resetLinkText;\n      resetLink.href = '#';\n      resetLink.style.color = styles.accentColor;\n      resetLink.style.fontSize = styles.fontSize;\n      resetLink.style.marginLeft = '16px';\n      resetLink.style.textDecoration = 'none';\n      resetLink.style.cursor = 'pointer';\n      resetLink.style.flexShrink = '0';\n      \n      // Add click handler for reset\n      resetLink.addEventListener('click', (e) => {\n        e.preventDefault();\n        // Select all items (reset to default state)\n        selectedItems = new Set(sortedDimensionValues);\n        updateCheckboxes();\n        updateHeaderLabel();\n        applyFilter();\n      });\n      \n      headerSection.appendChild(resetLink);\n    }\n    \n    // Create the search bar section\n    const searchBarSection = document.createElement('div');\n    searchBarSection.className = 'search-bar';\n    searchBarSection.style.padding = '8px 16px';\n    searchBarSection.style.display = 'flex';\n    searchBarSection.style.alignItems = 'center';\n    searchBarSection.style.borderBottom = `1px solid ${styles.searchBorderColor}`;\n    searchBarSection.style.backgroundColor = styles.searchBackgroundColor;\n    searchBarSection.style.boxSizing = 'border-box';\n    \n    // Create the search icon\n    const searchIcon = document.createElement('div');\n    searchIcon.className = 'search-icon';\n    searchIcon.innerHTML = `\n      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18px\" height=\"18px\" viewBox=\"0 0 24 24\" fill=\"${styles.searchTextColor}\">\n        <path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"></path>\n      </svg>\n    `;\n    searchIcon.style.marginRight = '8px';\n    searchIcon.style.flexShrink = '0';\n    \n    // Create the search input\n    const searchInput = document.createElement('input');\n    searchInput.type = 'text';\n    searchInput.placeholder = styles.searchPlaceholderText;\n    searchInput.style.border = 'none';\n    searchInput.style.outline = 'none';\n    searchInput.style.width = '100%';\n    searchInput.style.fontSize = styles.fontSize;\n    searchInput.style.color = styles.searchTextColor;\n    searchInput.style.backgroundColor = 'transparent';\n    searchInput.style.boxSizing = 'border-box';\n    \n    // Add elements to the search bar\n    searchBarSection.appendChild(searchIcon);\n    searchBarSection.appendChild(searchInput);\n    \n    // Create the items list container\n    const itemsListContainer = document.createElement('div');\n    itemsListContainer.className = 'items-list-container';\n    itemsListContainer.style.flex = '1';\n    itemsListContainer.style.overflowY = 'auto';\n    itemsListContainer.style.padding = '0';\n    itemsListContainer.style.boxSizing = 'border-box';\n    itemsListContainer.style.backgroundColor = styles.itemBackgroundColor;\n    \n    // Create the items list\n    const itemsList = document.createElement('div');\n    itemsList.className = 'items-list';\n    itemsList.style.boxSizing = 'border-box';\n    \n    // Format the metric value for display\n    function formatMetricValue(value) {\n      // If the value is a number, format it appropriately\n      if (typeof value === 'number') {\n        if (useCompactNumbers) {\n          // Format as compact number (10k, 5M, etc.)\n          if (value >= 1000000) {\n            return (value / 1000000).toFixed(1).replace(/\\.0$/, '') + 'M';\n          } else if (value >= 1000) {\n            return (value / 1000).toFixed(1).replace(/\\.0$/, '') + 'k';\n          } else {\n            return Math.round(value).toLocaleString();\n          }\n        } else {\n          // Format with commas\n          return Math.round(value).toLocaleString();\n        }\n      }\n      return value;\n    }\n    \n    displayValues.forEach(value => {\n      const itemRow = document.createElement('div');\n      itemRow.className = 'item';\n      itemRow.style.display = 'flex';\n      itemRow.style.alignItems = 'center';\n      itemRow.style.padding = '8px 16px';\n      itemRow.style.borderBottom = `1px solid ${styles.itemBorderColor}`;\n      itemRow.style.cursor = 'pointer';\n      itemRow.style.boxSizing = 'border-box';\n      itemRow.style.backgroundColor = styles.itemBackgroundColor;\n      \n      // Add hover effect\n      itemRow.addEventListener('mouseover', () => {\n        itemRow.style.backgroundColor = styles.itemHoverColor;\n      });\n      \n      itemRow.addEventListener('mouseout', () => {\n        itemRow.style.backgroundColor = styles.itemBackgroundColor;\n      });\n      \n      // Create the checkbox for this item\n      const itemCheckbox = document.createElement('input');\n      itemCheckbox.type = 'checkbox';\n      itemCheckbox.checked = selectedItems.has(value);\n      itemCheckbox.style.marginRight = '8px';\n      itemCheckbox.style.flexShrink = '0';\n      itemCheckbox.style.accentColor = styles.checkboxColor;\n      \n      // Create the item label container for flexible layout\n      const itemLabelContainer = document.createElement('div');\n      itemLabelContainer.style.flex = '1';\n      itemLabelContainer.style.display = 'flex';\n      itemLabelContainer.style.alignItems = 'center';\n      itemLabelContainer.style.justifyContent = 'space-between';\n      itemLabelContainer.style.marginRight = '8px';\n      itemLabelContainer.style.overflow = 'hidden';\n\n      // Create the item label\n      const itemLabel = document.createElement('span');\n      itemLabel.textContent = value;\n      itemLabel.style.fontSize = styles.fontSize;\n      itemLabel.style.color = styles.itemTextColor;\n      itemLabel.style.whiteSpace = 'nowrap';\n      itemLabel.style.overflow = 'hidden';\n      itemLabel.style.textOverflow = 'ellipsis';\n      itemLabel.style.marginRight = '8px';\n\n      // Create the metric label with the count for this value\n      const metricLabel = document.createElement('span');\n      const count = individualValueCounts.get(value) || 0;\n      metricLabel.textContent = formatMetricValue(count);\n      metricLabel.style.fontSize = styles.fontSize;\n      metricLabel.style.color = '#70757a'; // Metric color in gray\n      metricLabel.style.whiteSpace = 'nowrap';\n      metricLabel.style.flexShrink = '0';\n\n      // Add labels to the container\n      itemLabelContainer.appendChild(itemLabel);\n      itemLabelContainer.appendChild(metricLabel);\n\n      // Disable the \"only\" button\n      // const onlyButton = document.createElement('span');\n      // onlyButton.textContent = styles.onlyButtonText;\n      // onlyButton.style.color = styles.accentColor;\n      // onlyButton.style.fontSize = styles.onlyButtonFontSize;\n      // onlyButton.style.cursor = 'pointer';\n      // onlyButton.style.marginLeft = '8px';\n      // onlyButton.style.opacity = '0'; // Hide by default\n      // onlyButton.style.transition = 'opacity 0.2s';\n      // onlyButton.style.flexShrink = '0';\n      \n      // // Show \"only\" on hover\n      // itemRow.addEventListener('mouseover', () => {\n      //   onlyButton.style.opacity = '1';\n      // });\n      \n      // itemRow.addEventListener('mouseout', () => {\n      //   onlyButton.style.opacity = '0';\n      // });\n      \n      // Add click handlers\n      itemCheckbox.addEventListener('change', (e) => {\n        e.stopPropagation();\n        if (itemCheckbox.checked) {\n          selectedItems.add(value);\n        } else {\n          selectedItems.delete(value);\n        }\n        updateSelectAllCheckbox();\n        applyFilter();\n        \n        // Refresh the list to move selected items to the top\n        refreshItemsList();\n      });\n      \n      // Make the entire row clickable to toggle the checkbox\n      itemRow.addEventListener('click', (e) => {\n        // Only toggle if we didn't click on the checkbox\n        if (e.target !== itemCheckbox) {\n          // Toggle only this checkbox\n          itemCheckbox.checked = !itemCheckbox.checked;\n          if (itemCheckbox.checked) {\n            selectedItems.add(value);\n          } else {\n            selectedItems.delete(value);\n          }\n          updateSelectAllCheckbox();\n          applyFilter();\n          \n          // Refresh the list to move selected items to the top\n          refreshItemsList();\n          \n          // Prevent event bubbling to avoid multiple selections\n          e.stopPropagation();\n        }\n      });\n      \n      // onlyButton.addEventListener('click', (e) => {\n      //   e.stopPropagation(); // Prevent triggering the row click\n      //   selectedItems.clear();\n      //   selectedItems.add(value);\n      //   updateCheckboxes();\n      //   applyFilter();\n      // });\n      \n      // Add elements to the item row\n      itemRow.appendChild(itemCheckbox);\n      itemRow.appendChild(itemLabelContainer);\n      // itemRow.appendChild(onlyButton);\n      \n      // Add the item row to the list\n      itemsList.appendChild(itemRow);\n    });\n    \n    // Add the items list to its container\n    itemsListContainer.appendChild(itemsList);\n    \n    // Add all sections to the filter container\n    filterContainer.appendChild(headerSection);\n    filterContainer.appendChild(searchBarSection);\n    filterContainer.appendChild(itemsListContainer);\n    \n    // Add the filter container to the document\n    document.body.appendChild(filterContainer);\n    \n    // Function to update the header label with selected count\n    function updateHeaderLabel() {\n      if (showSelectedCount) {\n        // Count only the checked items (not the expanded filter values)\n        const selectedCount = selectedItems.size;\n        \n        // Always show the count of checked items\n        headerDimensionLabel.textContent = `${dimensionField.name} (${formatMetricValue(selectedCount)})`;\n      } else {\n        headerDimensionLabel.textContent = dimensionField.name;\n      }\n    }\n    \n    // Function to update the \"Select All\" checkbox state\n    function updateSelectAllCheckbox() {\n      // Check if all items are selected\n      const allSelected = selectedItems.size === sortedDimensionValues.length;\n      // Check if some (but not all) items are selected\n      const someSelected = selectedItems.size > 0 && selectedItems.size < sortedDimensionValues.length;\n      \n      selectAllCheckbox.checked = allSelected;\n      selectAllCheckbox.indeterminate = someSelected;\n      updateHeaderLabel();\n    }\n    \n    // Function to update all checkboxes based on selected items\n    function updateCheckboxes() {\n      const checkboxes = itemsList.querySelectorAll('input[type=\"checkbox\"]');\n      checkboxes.forEach((checkbox, index) => {\n        checkbox.checked = selectedItems.has(sortedDimensionValues[index]);\n      });\n      updateSelectAllCheckbox();\n    }\n    \n    // Add event listener for the \"Select All\" checkbox\n    selectAllCheckbox.addEventListener('change', () => {\n      if (selectAllCheckbox.checked) {\n        // Select all items\n        sortedDimensionValues.forEach(value => {\n          selectedItems.add(value);\n        });\n      } else {\n        // Deselect all items\n        selectedItems.clear();\n      }\n      updateCheckboxes();\n      applyFilter();\n      \n      // Refresh the list to update the order\n      refreshItemsList();\n    });\n    \n    // Add event listener for the search input\n    searchInput.addEventListener('input', () => {\n      const searchTerm = searchInput.value.toLowerCase();\n      const items = itemsList.querySelectorAll('.item');\n      \n      items.forEach((item, index) => {\n        // Get the value from the item's label text\n        const itemLabel = item.querySelector('span');\n        const value = itemLabel ? itemLabel.textContent : '';\n        \n        if (value.toLowerCase().includes(searchTerm)) {\n          item.style.display = 'flex';\n        } else {\n          item.style.display = 'none';\n        }\n      });\n    });\n    \n    // Function to apply the filter based on selected items\n    function applyFilter() {\n      if (selectedItems.size === 0 || selectedItems.size === sortedDimensionValues.length) {\n        // If nothing is selected or everything is selected, clear the filter\n    \n        dscc.clearInteraction('onClick');\n      } else {\n        // Apply filter with selected values\n        console.log(\"Applying filter with values:\", Array.from(selectedItems));\n        \n        // Create a list of values to filter on, including both individual values\n        // and any delimited fields containing those values\n        const filterValues = new Set();\n        \n        // Add all selected individual values\n        selectedItems.forEach(value => {\n          // Convert nullDisplayText back to actual null for the filter\n          const actualValue = value === nullDisplayText ? null : value;\n          filterValues.add(actualValue);\n          \n          // Also add any delimited fields containing this value\n          if (value !== nullDisplayText && delimitedValues.has(value)) {\n            delimitedValues.get(value).forEach(delimitedField => {\n              filterValues.add(delimitedField);\n            });\n          }\n        });\n        \n        // Create the filter interaction data object\n        const filterPayload = {\n          concepts: [dimensionField.id],\n          values: Array.from(filterValues).map(value => [value])\n        };\n        \n      \n        dscc.sendInteraction('onClick', dscc.InteractionType.FILTER, filterPayload);\n        \n        // Update the header label with the correct count (number of checked items)\n        updateHeaderLabel();\n      }\n    }\n    \n    // Function to refresh the items list with the current selection state\n    function refreshItemsList() {\n      // Clear the current list\n      while (itemsList.firstChild) {\n        itemsList.removeChild(itemsList.firstChild);\n      }\n      \n      // Get the updated sorted values\n      const updatedDisplayValues = getSortedValues();\n      \n      // Recreate the list with the new order\n      updatedDisplayValues.forEach(value => {\n        const itemRow = document.createElement('div');\n        itemRow.className = 'item';\n        itemRow.style.display = 'flex';\n        itemRow.style.alignItems = 'center';\n        itemRow.style.padding = '8px 16px';\n        itemRow.style.borderBottom = `1px solid ${styles.itemBorderColor}`;\n        itemRow.style.cursor = 'pointer';\n        itemRow.style.boxSizing = 'border-box';\n        itemRow.style.backgroundColor = styles.itemBackgroundColor;\n        \n        // Add hover effect\n        itemRow.addEventListener('mouseover', () => {\n          itemRow.style.backgroundColor = styles.itemHoverColor;\n        });\n        \n        itemRow.addEventListener('mouseout', () => {\n          itemRow.style.backgroundColor = styles.itemBackgroundColor;\n        });\n        \n        // Create the checkbox for this item\n        const itemCheckbox = document.createElement('input');\n        itemCheckbox.type = 'checkbox';\n        itemCheckbox.checked = selectedItems.has(value);\n        itemCheckbox.style.marginRight = '8px';\n        itemCheckbox.style.flexShrink = '0';\n        itemCheckbox.style.accentColor = styles.checkboxColor;\n        \n        // Create the item label container for flexible layout\n        const itemLabelContainer = document.createElement('div');\n        itemLabelContainer.style.flex = '1';\n        itemLabelContainer.style.display = 'flex';\n        itemLabelContainer.style.alignItems = 'center';\n        itemLabelContainer.style.justifyContent = 'space-between';\n        itemLabelContainer.style.marginRight = '8px';\n        itemLabelContainer.style.overflow = 'hidden';\n\n        // Create the item label\n        const itemLabel = document.createElement('span');\n        itemLabel.textContent = value;\n        itemLabel.style.fontSize = styles.fontSize;\n        itemLabel.style.color = styles.itemTextColor;\n        itemLabel.style.whiteSpace = 'nowrap';\n        itemLabel.style.overflow = 'hidden';\n        itemLabel.style.textOverflow = 'ellipsis';\n        itemLabel.style.marginRight = '8px';\n\n        // Create the metric label with the count for this value\n        const metricLabel = document.createElement('span');\n        const count = individualValueCounts.get(value) || 0;\n        metricLabel.textContent = formatMetricValue(count);\n        metricLabel.style.fontSize = styles.fontSize;\n        metricLabel.style.color = '#70757a'; // Metric color in gray\n        metricLabel.style.whiteSpace = 'nowrap';\n        metricLabel.style.flexShrink = '0';\n\n        // Add labels to the container\n        itemLabelContainer.appendChild(itemLabel);\n        itemLabelContainer.appendChild(metricLabel);\n        \n        // Add click handlers\n        itemCheckbox.addEventListener('change', (e) => {\n          e.stopPropagation();\n          if (itemCheckbox.checked) {\n            selectedItems.add(value);\n          } else {\n            selectedItems.delete(value);\n          }\n          updateSelectAllCheckbox();\n          applyFilter();\n          \n          // Refresh the list to move selected items to the top\n          refreshItemsList();\n        });\n        \n        // Make the entire row clickable to toggle the checkbox\n        itemRow.addEventListener('click', (e) => {\n          // Only toggle if we didn't click on the checkbox\n          if (e.target !== itemCheckbox) {\n            // Toggle only this checkbox\n            itemCheckbox.checked = !itemCheckbox.checked;\n            if (itemCheckbox.checked) {\n              selectedItems.add(value);\n            } else {\n              selectedItems.delete(value);\n            }\n            updateSelectAllCheckbox();\n            applyFilter();\n            \n            // Refresh the list to move selected items to the top\n            refreshItemsList();\n            \n            // Prevent event bubbling to avoid multiple selections\n            e.stopPropagation();\n          }\n        });\n        \n        // Add elements to the item row\n        itemRow.appendChild(itemCheckbox);\n        itemRow.appendChild(itemLabelContainer);\n        \n        // Add the item row to the list\n        itemsList.appendChild(itemRow);\n      });\n    }\n    \n    // Handle window resize events\n    window.addEventListener('resize', () => {\n      const newWidth = dscc.getWidth();\n      const newHeight = dscc.getHeight();\n      \n      // Update container dimensions\n      filterContainer.style.width = newWidth + 'px';\n      filterContainer.style.height = newHeight + 'px';\n    });\n    \n    console.log(\"Delimited field filter UI created successfully\");\n  } catch (error) {\n    console.error(\"Error in drawViz:\", error);\n  }\n}\n\n// Subscribe to data updates from Looker Studio\n// The objectTransform parameter ensures we get the data in the format we expect\ndscc.subscribeToData(drawViz, {transform: dscc.objectTransform});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });